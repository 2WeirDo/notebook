## 1. 邂逅版本控制工具

### 1.1. 认识版本控制（版本控制）

◼ 什么是版本控制？

-  版本控制的英文是Version control；
-  是维护工程蓝图的标准作法，能追踪工程蓝图从诞生一直到定案的过程；
-  版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步；

◼ 简单来说，版本控制在软件开发中，可以帮助程序员进行代码的追踪、维护、控制等等一系列的操作。



### 1.2. 版本控制的功能

对于我们日常开发，我们常常面临如下一些问题，通过版本控制可以很好的解决：

◼ **不同版本的存储管理**：

-  一个项目会不断进行版本的迭代，来修复之前的一些问题、增加新的功能、需求，甚至包括项目的重构；
-  如果我们通过手动来维护一系列的项目备份，简直是一场噩梦；

◼ **重大版本的备份维护**：

-  对于很多重大的版本，我们会进行备份管理；

◼ **恢复之前的项目版本**：

-  当我们开发过程中发生一些严重的问题时，想要恢复之前的操作或者回到之前某个版本；

◼ **记录项目的点点滴滴：**

-  如果我们每一个功能的修改、bug的修复、新的需求更改都需要记录下来，版本控制可以很好的解决；

◼ **多人开发的****代码合并****：**

-  项目中通常都是多人开发，将多人代码进行合并，并且在出现冲突时更好的进行处理；



### 1.3. 版本控制的历史

◼ 版本控制的史前时代（没有版本控制）：

-  人们通常通过文件备份的方式来进行管理，再通过diff命令来对比两个文件的差异；

◼ CVS（Concurrent Versions System）

-  第一个被大规模使用的版本控制工具，诞生于1985年；
-  由荷兰阿姆斯特丹VU大学的Dick Grune教授实现的，也算是SVN的前身（SVN的出现就是为了取代CVS的）。

◼ SVN（Subversion）

-  因其命令行工具名为svn因此通常被简称为SVN；
-  SVN由CollabNet公司于2000年资助并发起开发，目的是取代CVS，对CVS进行了很多的优化；
-  SVN和CVS一样，也属于集中式版本控制工具；
-  SVN在早期公司开发中使用率非常高，但是目前已经被Git取代；

◼ Git（Linus的作品）

-  早期的时候，Linux社区使用的是BitKeeper来进行版本控制；
-  但是因为一些原因，BitKeeper想要收回对Linux社区的免费授权；
-  于是Linus用了大概一周的时间，开发了Git用来取代BitKeeper；
-  Linus完成了Git的核心设计，在之后Linus功成身退，将Git交由另外一个Git的主要贡献者Junio C Hamano来维护

## 2. 集中式和分布式区别

### 2.1. 集中式版本控制

◼ CVS和SVN都是是属于集中式版本控制系统（Centralized Version Control Systems，简称 CVCS）

-  它们的主要特点是单一的集中管理的服务器，保存所有文件的修订版本；
-  协同开发人员通过客户端连接到这台服务器，取出最新的文件或者提交更新；

◼ 这种做法带来了许多好处，特别是相较于老式的本地管理来说，每个人都可以在一定程度上看到项目中的

其他人正在做些什么。

◼ 但是集中式版本控制也有一个核心的问题：中央服务器不能出现故障：

-  如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作；
-  如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据；

![img](./.assets/1685117368789-0ba7b50c-e58f-4969-a628-933f1ffc3e24.png)



### 2.2. 分布式版本控制

◼ Git是属于分布式版本控制系统（Distributed Version Control System，简称 DVCS）

-  客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录；
-  这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复；
-  因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份；

◼ 目前在公司开发中我们都是使用Git来管理项目的，所以接下来我们会重点学习Git的各种用法；

![img](./.assets/1685117403673-e2984ac6-77f4-4d9e-802f-dc5420b33627.png)





## 3. Git的环境安装搭建

### 3.1. Git的配置选项

◼ 安装Git后，要做的第一件事就是设置你的用户名和邮件地址。

-  这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改；
-  如果使用了`--global` 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息；

```git
git config --global user.name "xxx"
git config --global user.email "xxx@gmail.com"
```

◼ 检测当前的配置信息

```git
git config --list
```



### 3.2. Git的别名（alias）

◼ Git 并不会在你输入部分命令时自动推断出你想要的命令：

-  如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名

```git
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
```



## 4. Git初始化本地仓库



### 4.1. 获取Git仓库 – git init/git clone

◼ 我们需要一个Git来管理源代码，那么我们本地也需要有一个Git仓库。

◼ 通常有两种获取 Git 项目仓库的方式：

-  方式一：初始化一个Git仓库，并且可以将当前项目的文件都添加到Git仓库中（目前很多的脚手架在创建项目时都会默认创建一个Git仓库）；
-  方式二：从其它服务器 克隆（clone） 一个已存在的 Git 仓库（第一天到公司通常我们需要做这个操作）；

◼方式一：初始化Git仓库

-  该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的核心；
-  但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪；

```git
git init
```

◼ 方式二：从Git远程仓库

```git
git clone https://github.com/coderwhy/hy-react-web-music.git
```



## 5. Git记录更新变化过程

### 5.1. 文件的状态划分

◼ 现在我们的电脑上已经有一个Git仓库：

-  在实际开发中，你需要将某些文件交由这个Git仓库来管理；
-  并且我们之后会修改文件的内容，当达成某一个目标时，想要记录下来这次操作，就会将它提交到仓库中；

◼ 那么我们需要对文件来划分不同的状态，以确定这个文件是否已经归于Git仓库的管理：

-  未跟踪：默认情况下，Git仓库下的文件也没有添加到Git仓库管理中，我们需要通过add命令来操作；
-  已跟踪：添加到Git仓库管理的文件处于已跟踪状态，Git可以对其进行各种跟踪管理；



◼ 已跟踪的文件又可以进行细分状态划分：

-  staged：暂缓区中的文件状态；
-  Unmodified：commit命令，可以将staged中文件提交到Git仓库
-  Modified：修改了某个文件后，会处于Modified状态；

◼ 在工作时，你可以选择性地将这些修改过的文件放入暂存区；

◼ 然后提交所有已暂存的修改，如此反复；

![img](./.assets/1685117865077-c2dba39d-b0dd-410a-af39-5b34e9a5e560.png)





### 5.2. 检测文件的状态 - git status

◼ 我们在有Git仓库的目录下新建一个文件，查看文件的状态：

```git
git status
```

◼ Untracked files：未跟踪的文件

-  未跟踪的文件意味着 Git 在之前的提交中没有这些文件；
-  Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”；

◼ 我们也可以查看更加简洁的状态信息：

```git
git status –s
git status --short
```

 左栏指明了暂存区的状态，右栏指明了工作区的状态；

![img](./.assets/1685117937544-eb2377c6-747f-48ed-a3c5-9fc36b8ddc3a.png)



### 5.3. 文件添加到暂存区 – git add

◼ 跟踪新文件命令：

```git
git add aaa.js
```

-  使用命令 `git add` 开始跟踪一个文件。

◼ 跟踪修改的文件命令：

-  如果我们已经跟踪了某一个文件，这个时候修改了文件也需要重新添加到暂存区中；

◼ 通过git add . 将所有的文件添加到暂存区中：(常用)

```git
git add .
```





### 5.4. git忽略文件

◼ 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。

-  通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等；
-  我们可以创建一个名为 `.gitignore` 的文件，列出要忽略的文件的模式；

◼ 在实际开发中，这个文件通常不需要手动创建，在必须的时候添加自己的忽略内容即可；

◼ 比如下方是创建的Vue项目自动创建的忽略文件：

-  包括一些不需要提交的文件、文件夹；
-  包括本地环境变量文件；
-  包括一些日志文件；
-  包括一些编辑器自动生成的文件；

![img](./.assets/1685118098014-b5dd9909-2402-4345-a1cf-b7992a7fe061.png)



### 5.5. 文件更新提交 – git commit

◼ 现在的暂存区已经准备就绪，可以提交了。

-  每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了；
-  再运行提交命令 git commit；
-  可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行;

```git
git commit –m "提交信息"
```

◼ 如果我们修改文件的add操作，加上commit的操作有点繁琐，那么可以将两个命令结合来使用：

```git
git commit -a -m "提交信息"
```



### 5.6. Git的校验和

◼ Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。

-  Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）；
-  这是一个由 40 个十六进制字符（0-9 和 a-f）组成的字符串，基于 Git 中文件的内容或目录结构计算出来

![img](./.assets/1685118197771-c4976cd0-5713-4cee-946a-b300a0b23e39.png)





### 5.7. 查看提交的历史 – git log

◼ 在提交了若干更新，又或者克隆了某个项目之后，有时候我们想要查看一下所有的历史提交记录。

◼ 这个时候我们可以使用`git log`命令：

-  不传入任何参数的默认情况下，`git log` 会按时间先后顺序列出所有的提交，最近的更新排在最上面；
-  这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明；

```git
git log
git log --pretty=oneline  // 简约一点
git log --pretty=oneline --graph  // 以图结构展示, 后面分支会用到
```



### 5.8. 版本回退 – git reset

◼ 如果想要进行版本回退，我们需要先知道目前处于哪一个版本：`Git`通过`HEAD`指针记录当前版本。

-  HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交；
-  理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照；

![img](./.assets/1685118393891-9800be05-e34c-4695-b123-e693f97a7731.png)

◼ 我们可以通过HEAD来改变Git目前的版本指向：

-  上一个版本就是HEAD^，上上一个版本就是HEAD^^；
-  如果是上1000个版本，我们可以使用HEAD~1000；
-  我们可以可以指定某一个commit id；

```git
git reset --hard HEAD^  // 回退到上一个版本
git reset --hard HEAD~1000 // 回退到上一千个版本
git reset --hard 2d44982  // 回退到hash值以2d44982开头的版本
```





## 6. Git远程仓库

### 6.1. 什么是远程仓库？

◼ 什么是远程仓库（Remote Repository）呢？

-  目前我们的代码是保存在一个本地仓库中，也就意味着我们只是在进行本地操作；
-  在真实开发中，我们通常是多人开发的，所以我们会将管理的代码共享到远程仓库中；

◼ 那么如何创建一个远程仓库呢？

-  远程仓库通常是搭建在某一个服务器上的（当然本地也可以，但是本地很难共享）；
-  所以我们需要在Git服务器上搭建一个远程仓库；

◼ 目前我们有如下方式可以使用Git服务器：

-  使用第三方的Git服务器：比如GitHub、Gitee、Gitlab等等；
-  在自己服务器搭建一个Git服务；

### 6.2. 远程仓库的验证

◼ 目前Git服务器验证手段主要有两种：

-  方式一：基于HTTP的凭证存储（Credential Storage）；
-  方式二：基于SSH的密钥；



具体做法省略 ......



### 6.3. 管理远程服务器

◼ 查看远程地址：比如我们之前从GitHub上clone下来的代码，它就是有自己的远程仓库的：

```git
git remote
git remote –v   // -v是—verbose的缩写(冗长的)
```

![img](./.assets/1685118616240-e5fb6acb-3ce7-44aa-81af-139ef106c6ef.png)

◼ 添加远程地址：我们也可以继续添加远程服务器（让本地的仓库和远程服务器仓库建立连接）：

```git
git remote add origin <url>
git remote add origin <url>
```

◼ 重命名远程地址：

```git
git remote rename origin org
```

◼ 移除远程地址：

```git
git remote remove origin
```

"`git remote remove origin`"的意思就是从你的本地Git仓库中移除指向名为"origin"的远程仓库的引用。此操作并不会删除实际的远程仓库，只是删除了你的本地仓库与远程仓库的链接。

如果你想要改变你的远程仓库，或者你不再需要与名为"origin"的远程仓库的链接，你可以使用这个命令。



### 6.4. 本地分支的上游分支（跟踪分支）

◼ 问题一：当前分支没有`track`的分支

◼ 原因：当前分支没有和远程的`origin/master`分支进行跟踪

-  在没有跟踪的情况下，我们直接执行pull操作的时候必须指定从哪一个远程仓库中的哪一个分支中获取内容

◼ 如果我们想要直接执行`git pull`是有一个前提的：必须给当前分支设置一个跟踪分支：

```git
git branch --set-upstream-to=origin/main
```

### 6.5. 拒绝合并不相干的历史

◼ 问题二：合并远程分支时，拒绝合并不相干的历史

◼ 原因：我们将两个不相干的分支进行了合并：

-  简单来说就是：过去`git merge`允许将两个没有共同基础的分支进行合并，这导致了一个后果：新创建的项目可能被一个毫不怀疑的维护者合并了很多没有必要的历史，到一个已经存在的项目中，目前这个命令已经被纠正，但是我们依然可以通过`--allow-unrelated-histories`选项来逃逸这个限制，来合并两个独立的项目.

```git
git merge --allow-unrelated-histories
```

最后可以 `git push`



### 6.6. 远程仓库的交互

◼ 从远程仓库clone代码：将存储库克隆到新创建的目录中；

```git
git clone <url>
```

◼ 将代码`push`到远程仓库：将本地仓库的代码推送到远程仓库中；

-  默认情况下是将当前分支（比如master）push到origin远程仓库的；

```git
git push  
// 默认情况下，"git push" 命令会将当前所在的本地分支的提交推送到
// 与之关联的默认远程源的同名分支。 如果设置了上游分支则推送到上有分支上

git push origin master 
// 这个命令的作用是将当前本地分支的提交同步到远程仓库的 "master" 分支上
```

如果本地分支设置了上游分支（upstream branch），则 "git push" 命令会将当前所在的本地分支的提交推送到上游分支所在的远程仓库和分支上，而不是默认远程源的同名分支。

◼ 从远程仓库fetch代码：从远程仓库获取最新的代码

-  默认情况下是从origin中获取代码；

```git
git fetch
git fetch origin
```

-  获取到代码后默认并没有合并到本地仓库，我们需要通过merge来合并；

```git
git merge
```

◼ 从远程仓库pull代码：上面的两次操作有点繁琐，我们可以通过一个命令来操作

```git
git pull  
# git fetch + git merge (git rebase)
```



### 6.7. 合并冲突（conflict）

在ide操作即可, 修改完后记得 `git add .`







## 7. 常见的开源协议

最常见的用得最多的即是 `mit`协议

![img](./.assets/1685119634005-57368bc6-ff89-4a5f-88bc-aaaca28b67a6.png)





## 8. Git的标签tag用法

### 8.1. 创建tag

◼ 对于重大的版本我们常常会打上一个标签，以表示它的重要性：

-  Git 可以给仓库历史中的某一个提交打上标签；
-  比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）；

◼ 创建标签：

-  Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）；
-  附注标签：通过-a选项，并且通过-m添加额外信息；

```git
git tag v1.0
git tag -a v1.1 -m "附注标签"
```

◼ 默认情况下，`git push` 命令并不会传送标签到远程仓库服务器上。

-  在创建完标签后你必须显式地推送标签到共享服务器上，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签；

```git
git push origin v1.0
git push origin --tags
// 将本地仓库中的所有标签推送到与之关联的 "origin" 远程源上
```



### 8.2. 删除和检出tag

◼ **删除本地tag**：要删除掉你本地仓库上的标签，可以使用命令

```git
git tag -d <tagname>
```

◼ **删除远程tag**：要删除远程的tag我们可以通过

```git
git push origin –delete <tagname>
```

◼ **检出tag：**

-  如果你想查看某个标签所指向的文件版本，可以使用 `git checkout` 命令；
-  通常我们在检出tag的时候还会创建一个对应的分支（分支后续了解）；

```git
git checkout v1.0
```



## 9. Git分支的使用过程  🔥

### 9.1. Git提交对象（Commit Object）

◼ 几乎所有的版本控制系统都以某种形式支持分支。

-  使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。

◼ 在进行提交 (`git commit`)操作时，Git 会保存一个提交对象（commit object）：

-  该提交对象会包含一个指向暂存内容快照的指针；
-  该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针；

- - ✓ 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象；
  - ✓ 而由多个分支合并产生的提交对象有多个父对象；

![img](./.assets/1685120084561-bd6d190a-8de8-41ae-8025-1b883fbb26fd.png)

![img](./.assets/1685120092107-c838d95f-8a19-4c45-ac67-56702d9ae68f.png)



### 9.2. Git master分支

◼ Git 的分支，其实本质上仅仅是指向提交对象的可变指针。

-  Git 的默认分支名字是 `master`，在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 `master `分支；
-  `master` 分支会在每次提交时自动移动；

◼ `Git` 的 `master `分支并不是一个特殊分支。

-  它就跟其它分支完全没有区别；
-  之所以几乎每一个仓库都有 master 分支，是因为 `git init` 命令默认创建它，并且大多数人都懒得去改动它；

![img](./.assets/1685120240868-77163d54-8bc5-4fd0-8a97-a9922c81aa54.png)





### 9.3. Git创建分支

◼ Git 是怎么创建新分支的呢？

-  很简单，它只是为你创建了一个可以移动的新的指针；

◼ 比如，创建一个 testing 分支， 你需要使用` git branch `命令：

```git
git branch testing
```

![img](./.assets/1685120335067-d79eccd7-283b-4b45-beae-dcd3a4f6b7e7.png)

◼ 那么，**Git 如何切换分支呢 ?**

-  也很简单，它也是通过一个名为 HEAD 的特殊指针；

```git
git checkout testing
```

![img](./.assets/1685120367521-dc474030-b139-43d1-aad7-15d5eb14221a.png)



### 9.4. Git分支提交

◼ 如果我们指向某一个分支，并且在这个分支上提交：

![img](./.assets/1685120424206-ab656f4c-b16d-45ca-9443-ac070e8600b7.png)

◼ 你也可以切换回到master分支，继续开发

![img](./.assets/1685120449650-885a0861-951b-4589-bd26-fa5d04b9e12c.png)

下一步

![img](./.assets/1685120484193-af80cc1a-1957-4e79-8aee-9d46304f5364.png)



### 9.5. 创建分支同时切换

◼ 创建新分支的同时切换过去

-  通常我们会在创建一个新分支后立即切换过去；
-  这可以用 `git checkout -b <newbranchname>` 一条命令搞定；

```git
git checkout -b <newbranchname>
```



### 9.6. 为什么需要使用分支呢？

◼ 让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。

-  开发某个项目，在默认分支master上进行开发；
-  实现项目的功能需求，不断提交；
-  并且在一个大的版本完成时，发布版本，打上一个`tag v1.0.0`；

![img](./.assets/1685120647024-35a1da95-4d48-4766-960f-3900c3c638a6.png)

◼ 继续开发后续的新功能，正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补， 你将按照如下方式来处理：

-  切换到`tag v1.0.0`的版本，并且创建一个分支`hotfix`；

◼ 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 `-b` 参数的` git checkout` 命令：

```git
git checkout –b hotfix
```

![img](./.assets/1685120655272-09079f5a-ce7c-4213-b1ce-3757f3afb331.png)



### 9.7. 分支开发和合并

◼ 分支上开发、修复bug：

-  我们可以在创建的`hotfix`分支上继续开发工作或者修复bug；
-  当完成要做的工作后，重新打上一个新的`tag v1.0.1`；

![img](./.assets/1685120706569-6950c2a3-8f12-4a08-b7c5-de23fe18c438.png)

◼ 切换回`master`分支，但是这个时候`master`分支也需要修复刚刚的bug：

-  所以我们需要将`master`分支和`hotfix`分支进行合并

```git
git checkout master
git merge hotfix
```



![img](./.assets/1685120714786-e6944b7d-841c-4452-be9c-eb737412e19e.png)



### 9.8. 查看和删除分支

◼ 如果我们希望查看当前所有的分支，可以通过以下命令 : 

```git
git branch   # 查看当前所有的分支
git branch –v  # 同时查看最后一次提交
git branch --merged  # 查看所有合并到当前分支的分支
git branch --no-merged  # 查看所有没有合并到当前分支的分支
```

◼ 如果某些已经合并的分支我们不再需要了，那么可以将其移除掉：

```git
git branch –d hotfix # 删除当前分支
git branch –D hotfix # 强制删除某一个分支
```

## 10. 工作中的Git Flow

### 10.1. 什么是 `git flow`

◼ 由于Git上分支的使用的便捷性，产生了很多Git的工作流：

-  也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；
-  你可以定期地把某些主题分支合并入其他分支中；

◼ 比如以下的工作流：

-  `master`作为主分支；
-  `develop`作为开发分支，并且有稳定版本时，合并到`master`分支中；
-  `topic`作为某一个主题或者功能或者特性的分支进行开发，开发完成后合并到`develop`分支中

![img](./.assets/1685120896919-14f1d4a4-afab-4cd5-a72e-0d2354379a3b.png)

### 10.2. 比较常见的git flow

![img](./.assets/1685120913227-7de1138c-dc7b-4403-86fc-d2494d56465c.png)





## 11. Git远程分支的管理

### 11.1. Git的远程分支

◼ 远程分支是也是一种分支结构：

-  以 <remote>/<branch> 的形式命名的；

◼ 如果我们刚刚clone下来代码，分支的结构如下：

◼ 如果其他人修改了代码，那么远程分支结构如下：

-  你需要通过`fetch`来获取最新的远程分支提交信息；

进度一 : 

![img](./.assets/1685121068403-09440219-fcf4-4899-81f1-1d8cadbff91c.png)

进度二 :

![img](./.assets/1685121088411-5f93845a-cab4-46c8-8b12-44f288bc5710.png)

进度三 :

![img](./.assets/1685121133362-387405b3-43e8-4d15-b02a-256fdb30c0b8.png)

### 11.2. 远程分支的管理

◼ 操作一：推送分支到远程

-  当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上；
-  运行 `git push <remote> <branch>`；

```git
git push origin <branch>
```

◼ 操作二：跟踪远程分支

-  当克隆一个仓库时，它通常会自动地创建一个跟踪 `origin/master` 的 `master` 分支；
-  如果你愿意的话可以设置其他的跟踪分支, 可以通过运行 `git checkout --track <remote>/<branch>`
-  如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支；

```git
git checkout --track <remote>/<branch>
git checkout <branch> 
```

◼ 操作三：删除远程分支

-  如果某一个远程分支不再使用，我们想要删除掉，可以运行带有 `--delete` 选项的 `git push` 命令来删除一个远程分支

```git
git push origin --delete <branch>
```

## 12. Git rebase的使用

### 12.1. Git rebase用法

◼ 在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase.

![img](./.assets/1685121568331-58a27d7b-eb5e-4c79-b6f8-67bf620b8379.png)



◼ 什么是rebase呢？

-  在上面的图例中，你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次；
-  在 Git 中，这种操作就叫做 变基（rebase）；
-  你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样；
-  rebase这个单词如何理解呢？

- - ✓ 我们可以将其理解成改变当前分支的base；
  - ✓ 比如在分支experiment上执行`rebase master`，那么可以改变`experiment`的`base`为`master`

```git
git checkout experiment
git rebase master
```

![img](./.assets/1685121378404-acb27e8a-c48d-43b9-b491-037f726853e2.png)



### 12.2. rebase的原理

◼ rebase是如何工作的呢？

-  它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2；
-  然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件；
-  然后将当前分支指向目标基底 C3；
-  最后以此将之前另存为临时文件的修改依序应用；

◼ 我们可以再次执行`master`上的合并操作



```git
$ git checkout master
$ git merge experiment
```

![img](./.assets/1685121663608-48ea467f-fa45-4914-bd11-f6cb8424cd9b.png)





### 12.3. rebase和merge的选择

◼ 开发中对于`rebase`和`merge`应该如何选择呢？

◼ 事实上，`rebase`和`merge`是对`Git`历史的不同处理方法：

-  `merge`用于记录git的所有历史，那么分支的历史错综复杂，也全部记录下来；
-  `rebase`用于简化历史记录，将两个分支的历史简化，整个历史更加简洁；

◼ 了解了`rebase`的底层原理，就可以根据自己的特定场景选择`merge`或者`rebase`。

◼ 注意：`rebase`有一条黄金法则：**永远不要在主分支上使用rebase**

-  如果在`main`上面使用`rebase`，会造成大量的提交历史在`main`分支中不同；
-  而多人开发时，其他人依然在原来的`main`中，对于提交历史来说会有很大的变化；

![img](./.assets/1685121764650-cd6a82dc-5de7-4e61-a8ad-95f8509327f9.png)





## 13. Git常见命令速查表

![img](./.assets/1685121799649-25d762ff-24e9-416c-9c58-69219bc704fe.png)