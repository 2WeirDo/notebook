**任何新技术的出现都是为了解决原有技术的某个痛点。**



## 1. javascript的痛点

◼ 优秀的JavaScript没有缺点吗？

*  其实上由于各种历史因素，JavaScript语言本身存在很多的缺点；
*  比如ES5以及之前的使用的var关键字关于作用域的问题；
*  比如最初JavaScript设计的数组类型并不是连续的内存空间；
*  比如直到今天JavaScript也没有加入类型检测这一机制；

◼ JavaScript正在慢慢变好

*  不可否认的是，JavaScript正在慢慢变得越来越好，无论是从底层设计还是应用层面。
*  ES6、7、8等的推出，每次都会让这门语言更加现代、更加安全、更加方便。
*  但是知道今天，JavaScript在类型检测上依然是毫无进展（为什么类型检测如此重要，我后面会聊到）

◼ 首先你需要知道，编程开发中我们有一个共识：**错误出现的越早越好**

*  能在**写代码的时候**发现错误，就不要在**代码编译时**再发现（IDE的优势就是在代码编写过程中帮助我们发现错误）。
*  能在**代码编译期间**发现错误，就不要在**代码运行期间**再发现（类型检测就可以很好的帮助我们做到这一点）。
*  能在**开发阶段**发现错误，就不要在**测试期间**发现错误，能在**测试期间**发现错误，就不要在**上线后**发现错误

◼ 所以我们经常会说JavaScript**不适合开发大型项目**，因为当项目一旦庞大起来，这种宽松的类型约束会带来非常多的安全隐患，多人员开发它们之间也没有良好的类型契约。

*  比如当我们去实现一个核心类库时，如果没有类型约束，那么需要对别人传入的参数进行各种验证来保证我们代码的健壮性；
*  比如我们去调用别人的函数，对方没有对函数进行任何的注释，我们只能去看里面的逻辑来理解这个函数需要传入什么参数，返回值是什么类型；



## 2. 认识TypeScript

`TypeScript`是拥有类型的`JavaScript`**超集**，它可以编译成**普通、干净、完整**的`JavaScript`代码。

◼ 怎么理解上面的话呢？

*  我们可以将TypeScript理解成**加强版**的JavaScript。
*  支持最新JavaScript特性
*  TypeScript在实现新特性的同时，总是保持和ES**标准的同步甚至是领先**；
*  并且在语言层面上，不仅仅**增加了类型约束**，而且**包括一些语法的扩展**，比如枚举类型（Enum）、元组类型（Tuple）等；
*  并且TypeScript最终会被编译成JavaScript代码，所以你并不需要担心它的**兼容**性问题，在编译时也可以不借助于Babel这样的工具；

所以，我们可以把TypeScript理解成更加强大的JavaScript，不仅让JavaScript更加安全，而且给它带来了诸多好用的好用特性；

![img](https://weirdo-blog.oss-cn-chengdu.aliyuncs.com/blog/202308181140843.png)



## 3. TypeScript的编译和运行环境

```git
# 安装命令
npm install typescript -g

# 查看版本
tsc --version

# 运行typescript文件
tsc 文件名

# 这时生成了相关js文件后就可以在html中引用js文件了


# 如果我们每次为了查看TypeScript代码的运行效果，都通过经过两个步骤的话就太繁琐了：
# 使用ts-node ，为TypeScript的运行提供执行环境；

# 1. 安装所需依赖
npm install ts-node -g
npm install tslib @types/node -g

# 2. 执行文件
ts-node ts文件名  # 直接在node中执行
```

当然, 在vscode中安装code runner插件最便捷



## 4. 标识符的类型注解及类型推导

```typescript
// string: TypeScript给我们定义标识符时, 提供的字符串类型
// String: JavaScript中字符串的包装类
let message: string = "Hello World"
// 声明一个标识符时, 如果有直接进行赋值, 会根据赋值的类型推导出标识符的类型注解
// 这个过程称之为类型推导
// let进行类型推导, 推导出来的通用类型
// const进行类型推导, 推导出来的字面量类型(后续专门讲解)
let name = "why"
let age = 18
const height = 1.88
```

 let进行类型推导, 推导出来的通用类型

 const进行类型推导, 推导出来的字面量类型(后续专门讲解)