## 1. v8引擎的执行原理

![img](https://cdn.nlark.com/yuque/0/2023/png/29006943/1681437539783-c73e472f-96f8-4163-8ffa-672e73798bc9.png)

◼ `Parse`模块会将`JavaScript`代码转换成`AST`（抽象语法树），这是因为解释器并不直接认识`JavaScript`代码；

- 如果函数没有被调用，那么是不会被转换成`AST`的；

◼ `Ignition`是一个解释器，会将`AST`转换成`ByteCode`（字节码）

- 同时会收集`TurboFan`优化所需要的信息（比如函数参数的类型信息，有了类型才能进行真实的运算）；
- 如果函数只调用一次，`Ignition`会解释执行`ByteCode`；

◼ `TurboFan`是一个编译器，可以将字节码编译为`CPU`可以直接执行的机器码；

- 如果一个函数被多次调用，那么就会被标记为**热点函数**，那么就会经过`TurboFan`转换成优化的机器码，提高代码的执行性能；
-  但是，机器码实际上也会被还原为`ByteCode`，这是因为如果后续执行函数的过程中，类型发生了变化（比如`sum`函数原来执行的是`number`类型，后来执行变成了`string`类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码；



## 2. JavaScript执行代码的具体流程

`javaScript`执行代码的流程可以分为以下几个主要阶段：

**1.词法分析（Lexical Analysis）**
JavaScript引擎首先将源代码分解成更小的、有意义的单元，称为词法单元（`tokens`）。这个过程类似于将一段文本拆分成单词和标点符号。词法分析器（`Lexer`）会根据JavaScript语言的语法规则将代码拆分成词法单元。

**2 语法分析（Parsing）**
在词法分析完成后，语法分析器（`Parser`）将词法单元组合成一个抽象语法树（Abstract Syntax Tree, AST）。抽象语法树是一种树形结构，用于表示代码的语法结构。每个节点代表一个语法成分，例如变量声明、函数定义、运算符等。

**3 生成字节码（Bytecode Generation）**
某些JavaScript引擎（如`V8`）会将抽象语法树转换为字节码（`Bytecode`），字节码是一种介于源代码和机器码之间的中间表示形式。将代码转换为字节码的主要优点是可以提高执行速度和跨平台兼容性。

**4 解释与编译（Interpretation and Compilation）**
根据不同的`JavaScript`引擎，代码会经历解释执行、即时编译（`JIT` Compilation）或混合的执行方式。解释执行是逐行解释并执行字节码的过程，而即时编译则是将字节码动态编译为机器码并执行。混合方式则结合了解释执行和即时编译的优点，例如`V8`引擎首先使用解释器（`Ignition`）快速解释执行字节码，然后基于运行时性能数据，将**热点代码**（经常执行的部分）通过即时编译器（`TurboFan`）编译为高效的机器码。

**5 优化与反优化（Optimization and Deoptimization）**
在代码执行过程中，`JavaScript`引擎会对代码进行优化，以提高执行速度。例如，`V8`引擎会对热点代码进行类型推断、内联函数等优化。然而，优化的过程是基于假设的，当假设不成立时，引擎需要进行反优化（`Deoptimization`），将优化后的代码恢复到未优化的状态，然后重新执行。

**6 垃圾回收（Garbage Collection）**
在JavaScript代码执行过程中，引擎需要负责内存的分配和回收。当对象不再被引用时，垃圾回收器（Garbage Collector）会自动回收这些对象所占用的内存，以防止内存泄漏。

**总结：**
JavaScript执行代码的流程包括词法分析、语法分析、生成字节码、解释与编译、优化与反优化以及垃圾回收等阶段。这些阶段共同完成了JavaScript代码从源代码到实际执行的整个过程。在执行过程中，不同的JavaScript引擎会采用不同的策略和技术进行优化，如V8引擎采用了即时编译（JIT）和多层次的优化策略。同时，垃圾回收器在执行过程中负责内存的管理，以防止内存泄漏和提高内存利用率。


 



## 3. javascript在内存中的执行过程

### 3.1. 初始化全局对象

◼ js引擎会在执行代码之前，会在堆内存中创建一个全局对象：`Global Object（GO）`

- 该对象所有的作用域（`scope`）都可以访问；
- 里面会包含`Date、Array、String、Number、setTimeout、setInterval`等等；
- 其中还有一个`window`属性指向自己；



### 3.2. 执行上下文  (Execution Contexts)

◼ js引擎内部有一个执行上下文栈（`Execution Context Stack`，简称`ECS`），它是用于执行代码的调用栈。

◼ 那么现在它要执行谁呢？执行的是全局的代码块：

- 全局的代码块为了执行会构建一个 `Global Execution Context`（`GEC`）；
- `GEC`会被放入到`ECS`中执行；

◼ `GEC`被放入到`ECS`中里面包含两部分内容：

- 第一部分：在代码执行前，在`parser`转成`AST`的过程中，会将全局定义的变量、函数等加入到`GlobalObject`中，但是并不会赋值；

- -  这个过程也称之为变量的作用域提升（`hoisting`）

- 第二部分：在代码执行中，对变量赋值，或者执行其他的函数；



### 3.3. 认识VO对象(Variable Object)

每一个执行上下文会关联一个`VO`（`Variable Object`，变量对象），变量和函数声明会被添加到这个`VO`对象中。

当全局代码被执行的时候，`VO`就是`GO`对象了





### 3.4. 函数如何被执行呢？

◼ 在执行的过程中执行到一个函数时，就会根据函数体创建一个函数执行上下文（`Functional Execution Context`，简称FEC），并且压入到`EC Stack`中。

◼ 因为每个执行上下文都会关联一个`VO`，那么函数执行上下文关联的`VO`是什么呢？

- 当进入一个函数执行上下文时，会创建一个`AO`对象（`Activation Object`）；
- 这个`AO`对象会使用`arguments`作为初始化，并且初始值是传入的参数；
- 这个`AO`对象会作为执行上下文的`VO`来存放变量的初始化；



## 4. 作用域和作用域链 ( Scope Chain )



### 4.1. 定义

**作用域**

作用域是`JavaScript`代码中定义变量和函数的可访问范围。作用域分为全局作用域和局部作用域（函数作用域）。在全局作用域中定义的变量和函数可以在整个程序中访问，而在局部作用域中定义的变量和函数只能在该作用域内访问。函数内部可以访问全局作用域和其外部作用域的变量，这种行为被称为作用域链。



**作用域链**

作用域链是一个包含多个作用域的列表，它定义了变量和函数的访问顺序。当查找一个变量或函数时，`JavaScript`引擎会按照作用域链从当前作用域开始，逐级向上查找，直到找到目标变量或函数，或者到达全局作用域。作用域链的顶端是当前函数的激活对象（包含局部变量和参数），然后是外部函数的激活对象，依此类推，直到全局对象。作用域链可以确保变量和函数在其定义的范围内被正确访问。

## 

◼ 当进入到一个执行上下文时，执行上下文也会关联一个作用域链（`Scope Chain`）

- 作用域链是一个对象列表，用于变量标识符的求值；
- 当进入一个执行上下文时，这个作用域链被创建，并且根据代码类型，添加一系列的对象；





### 4.1. 作用域链面试题

```js
var n = 100

function foo1() {
  console.log(n)
}
function foo2() {
  var n = 200
  console.log(n)
  foo1()
}
foo2()  
// 输出
// 200
// 100
// 说明foo1执行的结果只跟函数声明的位置有关, 而跟执行的位置无关
```



```javascript

var n = 100
    function foo() {
      console.log(n)
      return
      var n = 200
    }
    foo() 
// 输出
// undefined
// 说明return不会阻挡var的声明提升
```



```js
   function foo() {
      var a = b = 100
    }
    foo()
    console.log(b)
// 输出
// 100
// 这样操作的话b是全局变量, 但严格模式不行, 所以尽量不要这样赋值
```

