## 1. arguments

◼ `arguments` 是一个 对应于 传递给函数的参数的类数组(array-like)对象。

◼ array-like意味着它**不是一个数组类型，而是一个对象类型**：

- 但是它却拥有数组的一些特性，比如说`length`，比如可以通过`index`索引来访问；
- 但是它却没有数组的一些方法，比如`filter`、`map`等；



### 1.1. arguments转Array

◼ 转化方式一：

* 遍历`arguments`，添加到一个新数组中；

◼ 转化方式二：

* 调用数组`slice`函数的`call`方法；

◼ 转化方式三：ES6中的两个方法

* `Array.from`

* [`…arguments`]



```javascript
// 1.将arguments转成数组方式一:
var newArguments = []
for (var arg of arguments) {
  newArguments.push(arg)
}
console.log(newArguments)


// 2.将arguments转成数组方式二: 调用slice方法
var newArgs = [].slice.apply(arguments)
// var newArgs = Array.prototype.slice.apply(arguments)
console.log(newArgs)


// 3.将arguments转成数组方式三: ES6中方式
var newArgs1 = Array.from(arguments)
console.log(newArgs1)
var newArgs2 = [...arguments]
console.log(newArgs2)
```





## 2. 函数的剩余（rest）参数

◼ 如果最后一个参数是 `...`  为前缀的，那么它会将剩余的参数放到该参数中，并且作为一个数组；

◼ 那么剩余参数和`arguments`有什么区别呢？

- 剩余参数只包含那些没有对应形参的实参，而 `arguments` 对象包含了传给函数的所有实参；
- `arguments`对象不是一个真正的数组，而`rest`参数是一个真正的数组，可以进行数组的所有操作；
- `arguments`是早期的`ECMAScript`中为了方便去获取所有的参数提供的一个数据结构，而`rest`参数是`ES6`中提供并且希望以此来替代`arguments`的；

◼ 剩余参数**必须放到最后一个位置**，否则会报错。

- 注意：**rest参数是不参与参数的个数的**；



## 3. 理解JavaScript纯函数

◼ 纯函数的维基百科定义：

> 在程序设计中，若一个函数符合以下条件，那么这个函数被称为纯函数：

1. 此函数在相同的输入值时，需产生相同的输出。
2.  函数的输出和输入值以外的其他隐藏信息或状态无关，也和由I/O设备产生的外部输出无关。
3.  该函数不能有语义上可观察的函数副作用，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。

◼ 当然上面的定义会过于的晦涩，所以我简单总结一下：

- 确定的输入，一定会产生确定的输出；
- 函数在执行过程中，不能产生副作用；

### 3.1. 什么是副作用呢?

- 表示在执行一个函数时，除了返回函数值之外，还对调用函数产生了附加的影响，
- **比如修改了全局变量，修改参数或者改变外部的存储**；



◼ 纯函数在执行的过程中就是不能产生这样的副作用：

- 副作用往往是产生`bug`的 “温床”。



### 3.2. 纯函数的案例

◼ 我们来看一个对数组操作的两个函数：

- `slice`：`slice`截取数组时不会对原数组进行任何操作,而是**生成一个新的数组**；
- `splice`：`splice`截取数组, 会返回一个新的数组, **会对原数组进行修改**；

◼ `slice`就是一个纯函数，不会修改数组本身，而splice函数不是一个纯函数；

![img](https://cdn.nlark.com/yuque/0/2023/png/29006943/1681462609524-e91828fb-4d5a-40df-9d37-c81c898649b8.png)



### 3.3. 纯函数的作用和优势

◼ 为什么纯函数在函数式编程中非常重要呢？

- 因为你可以**安心的编写和安心的使用**；
- 你在写的时候保证了函数的纯度，只是单纯实现自己的业务逻辑即可，不需要关心传入的内容是如何获得的或者依赖其他的外部变量是否已经发生了修改；
- 你在用的时候，你确定你的输入内容不会被任意篡改，并且自己确定的输入，一定会有确定的输出；





## 4. 函数柯里化



### 4.1. 概念的理解

◼ 我们先来看一下维基百科的解释：

- 在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化；
- **是把接收多个参数的函数，变成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数，而且返回结果的新函数的技术；**
- 柯里化声称 “如果你固定某些参数，你将得到接受余下参数的一个函数”；

◼ 维基百科的结束非常的抽象，我们这里做一个总结：

- 🔥**只传递给函数一部分参数来调用它，让它返回一个函数去处理剩余的参数；**
- 这个过程就称之为柯里化；

◼ 柯里化是一种函数的转换，将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。

- 柯里化不会调用函数。它只是对函数进行转换。



### 4.2. 柯里化的优势

#### 4.2.1. 函数的职责单一

- 在函数式编程中，我们其实往往希望一个函数处理的问题尽可能的单一，而不是将一大堆的处理过程交给一个函数来处理；
- 那么我们是否就可以将每次传入的参数在单一的函数中进行处理，处理完后在下一个函数中再使用处理后的结果；



#### 4.2.2. 函数的参数服用

◼ 另外一个使用柯里化的场景是可以帮助我们可以复用参数逻辑：

![img](https://cdn.nlark.com/yuque/0/2023/png/29006943/1681462921568-72886512-5d27-49cf-9f33-47557af9edf5.png)

- makeAdder函数要求我们传入一个num（并且如果我们需要的话，可以在这里对num进行一些修改）；
- 在之后使用返回的函数时，我们不需要再继续传入num了；



### 4.3. 手写自动柯里化函数🔥

```javascript
function foo(a,b,c){
  return a+b+c;
}
function curring(fn){
  function cur(...args){
    if(args.length>=fn.length){
      return fn.apply(this,args);
    }else{
      return function(...newargs){
        return cur.apply(this,args.concat(newargs));
      }
    }
  }
  return cur;
}
let add=curring(foo);
console.log(add(1,2,3)); // 6
console.log(add(1)(2)(3)); // 6
```



## 5. 组合函数 

>  感觉没啥用

- 比如我们现在需要对某一个数据进行函数的调用，执行两个函数fn1和fn2，这两个函数是依次执行的；

- 那么如果每次我们都需要进行两个函数的调用，操作上就会显得重复；

- 那么是否可以将这两个函数组合起来，自动依次调用呢？

- 这个过程就是对函数的组合，我们称之为 组合函数（Compose Function）；


![img](https://cdn.nlark.com/yuque/0/2023/png/29006943/1681463099854-145f3e2c-c797-4b6c-90b5-3db9e7915386.png)



## 6. 严格模式



### 6.1. 认识严格模式

◼ JavaScript历史的局限性：

- 长久以来，JavaScript 不断向前发展且并未带来任何兼容性问题；

- 新的特性被加入，旧的功能也没有改变，这么做有利于兼容旧代码；

- 但**缺点是 JavaScript 创造者的任何错误或不完善的决定也将永远被保留在 JavaScript 语言中**；


◼ 在ECMAScript5标准中，JavaScript提出了严格模式的概念（Strict Mode）：

- 严格模式很好理解，是一种具有限制性的JavaScript模式，从而使代码隐式的脱离了 ”懒散（sloppy）模式“；

- 支持严格模式的浏览器在检测到代码中有严格模式时，会以更加严格的方式对代码进行检测和执行；


◼ 严格模式对正常的JavaScript语义进行了一些限制：

- **严格模式通过 抛出错误 来消除一些原有的静默（silent）错误；**
- **严格模式让JS引擎在执行代码时可以进行更多的优化（不需要对一些特殊的语法进行处理）；**
- **严格模式禁用了在ECMAScript未来版本中可能会定义的一些语法；**



> 如何开启呢?

严格模式通过在文件或者函数开头使用 `"use strict"` 来开启。

- 可以支持在**`js`文件**中开启严格模式；

- 也支持对某一个**函数**开启严格模式；




### 6.2. 严格模式的变化和限制

◼ 这里我们来说几个严格模式下的严格语法限制：

- JavaScript被设计为新手开发者更容易上手，所以有时候本来错误语法，被认为也是可以正常被解析的；

- 但是这种方式可能给带来留下来安全隐患；

- 在严格模式下，这种失误就会被当做错误，以便可以快速的发现和修正；


◼ 1. **无法意外的创建全局变量**

◼ 2. 严格模式会使引起**静默失败**(silently fail,注:不报错也没有任何效果)的赋值操作抛出异常

◼ 3. 严格模式下**试图删除不可删除的属性会报错**

◼ 4.严格模式**不允许函数参数有相同的名称**

◼ 5. **不允许0的八进制语法**

◼ 6. 在严格模式下，**不允许使用with**

◼ 7. 在严格模式下，**eval不再为上层引用变量(不懂)**



### 6.3. 严格模式下this指向问题



在严格模式下，`JavaScript`中的`this`绑定行为发生了一些变化。以下是几个主要的变化：



1. **全局作用域中的this不再指向全局对象**，而是`undefined`。这是为了避免在全局作用域中意外地修改全局对象。

1. 在函数中，如果没有明确指定`this`的值，那么`this`默认为`undefined`。在非严格模式下，如果没有明确指定`this`的值，`this`会自动绑定到全局对象。

1. 在函数调用时，**如果将`null`或`undefined`作为`this`的值传递给`call`、`apply`或`bind`方法，这些方法不再将`this`绑定到全局对象。相反，它们将保持原样，即`null`或`undefined`。**

1. 在函数调用时，如果使用箭头函数，则`this`绑定到箭头函数声明时所在的词法作用域。这与非严格模式下不同，非严格模式下箭头函数中的`this`默认绑定到外层作用域。



1. 普通模式下在全局作用域函数中的this指向`window`对象
2. 严格模式下全局作用域中函数中的 `this`  是 `undefined`
3. 普通模式下构造函数时不加 `new` 也可以调用，当普通函数，`this`指向全局对象
4. 严格模式下，如果构造函数不加 `new` 调用，`this`指向的是 `undefined` ，如果给它赋值，会报错
5. `new` 实例化的构造函数指向创建的对象实例
6. 定时器 `this` 还是指向`window`
7. 事件、对象还是指向调用者



