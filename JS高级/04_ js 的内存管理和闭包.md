## 1. javascript的内存管理

`JS`对于原始数据类型内存的分配会在执行时，直接在栈空间进行分配；

`JS`对于复杂数据类型内存的分配会在堆内存中开辟一块空间，并且将这块空间的指针返回值变量引用；



## 2. JavaScript的垃圾回收  🔥



### 2.1. 常见的GC算法:



#### 2.1.1. 引用计数：

 当一个对象有一个引用指向它时，那么这个对象的引用就`+1`；

 当一个对象的引用为`0`时，这个对象就可以被销毁掉；

◼ 这个算法有一个很大的弊端就是会产生循环引用, 它可能导致内存泄漏；

![img](https://cdn.nlark.com/yuque/0/2023/png/29006943/1681459762012-355e20cd-5857-4100-a205-f5a03eeabc1b.png)



#### 2.1.2. 标记清除🔥：

-  标记清除的核心思路是可达性（Reachability）
-  这个算法是设置一个根对象（root object），垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于哪些没有引用到的对象，就认为是不可用的对象；
-  这个算法可以**很好的解决循环引用**的问题；



#### 2.1.3. 其它算法优化补充

◼ JS引擎比较广泛的采用的就是可达性中的标记清除算法，当然类似于V8引擎为了进行更好的优化，它在算法的实现细节上也会结合一些其他的算法。

◼ **标记整理**（Mark-Compact） 和“标记－清除”相似；

- 不同的是，回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而**整合空闲空间，避免内存碎片化**；

◼ 分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。

- 许多对象出现，完成它们的工作并很快死去，它们可以很快被清理；
-  那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少；

◼ **增量收集**（Incremental collection）

- 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。
- 所以引擎试图将垃圾收集工作**分成几部分来做**，然后将这几部分会**逐一进行处理**，这样会有许多微小的延迟而不是一个大的延迟；

◼ **闲时收集**（Idle-time collection）

- 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。



### 2.2. V8引擎内存图

◼ 事实上，V8引擎为了提供内存的管理效率，对内存进行非常详细的划分：

![img](https://cdn.nlark.com/yuque/0/2023/png/29006943/1681460023539-3325dcb5-d244-4654-8161-6396abc08a77.png)





## 3. 闭包  🔥🔥🔥



### 3.1. 闭包的定义

◼ 我们来看一下MDN对JavaScript闭包的解释：

- 一个函数和对其周围状态（`lexical environment`，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（`closure`）；
- 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；
-  在 `JavaScript` 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；

◼ 那么我的理解和总结：

- 一个普通的**函数** `function`，如果它**可以访问外层作用域的自由变量，那么这个函数和周围环境就是一个闭包**；
- 从广义的角度来说：`JavaScript`中的函数都是闭包；
- 从狭义的角度来说：`JavaScript`中一个函数，如果访问了外层作用域的变量，那么它是一个闭包；

------

> 以下更易理解

**闭包可以理解为一个函数和它引用的外部环境之间的关系。换句话说，闭包是一个函数和它捕获的变量和作用域的组合。**



🔥在`JavaScript`中，函数是一等公民，可以作为参数传递给其他函数，也可以作为返回值返回。当一个函数被定义在另一个函数的内部时，这个内部函数可以访问它所在的外部函数的变量。当外部函数执行完毕后，理论上它的局部变量和作用域应该被销毁。但如果内部函数依然保持对这些变量和作用域的引用，它们就不会被销毁。这就是闭包。



闭包有以下几个特点：

1. **内部函数可以访问外部函数的变量和作用域**，即使外部函数已经执行完毕。
2. **闭包可以实现数据的封装和私有化**，因为闭包内的变量对外部作用域是不可见的。
3. **闭包的生命周期比普通函数长**，因为它们会持有对外部变量和作用域的引用，直到这些引用被释放。



举个简单的例子来说明闭包：

```javascript
function outer() {
  var count = 0;

  function inner() {
    count++;
    console.log(count);
  }

  return inner;
}

var counter = outer();
counter(); // 输出 1
counter(); // 输出 2
```

在这个例子中，`outer`函数返回了一个`inner`函数，该函数可以访问`outer`函数的局部变量`count`。当我们调用`counter()`时，它实际上是在调用`inner`函数，并访问并修改`count`变量。由于`inner`函数持有对`count`的引用，所以`count`变量不会在`outer`函数执行完毕后被销毁，这就是一个典型的闭包。



### 3.2. 闭包的内存泄漏以及如何解决 🔥🔥

闭包可能导致内存泄漏，主要原因是闭包持有对外部变量和作用域的引用，使得这些资源无法被垃圾回收器回收。在某些情况下，这可能导致无法回收的内存持续增加，从而导致内存泄漏。这里举一个例子说明闭包可能导致的内存泄漏问题：

```javascript
function addEvent(element) {
  var largeData = new Array(1000000).join('*');

  element.onclick = function() {
    console.log('Element clicked, largeData length: ' + largeData.length);
  };
}
```

在上面的例子中，我们创建了一个大的字符串`largeData`，然后为`DOM`元素绑定了一个点击事件处理函数。这个事件处理函数形成了一个闭包，因为它访问了外部函数的变量`largeData`。**由于事件处理函数持有对`largeData`的引用，`largeData`将无法被回收，导致内存泄漏。**



解决闭包导致的内存泄漏问题，可以采取以下策略：



1. **最小化闭包的生命周期**：尽量在使用闭包后立即释放它们，以减少对外部变量和作用域的引用时间。



2. **及时解除引用**：当不再需要闭包时，将闭包内部引用的外部变量设为`null`，这样可以帮助垃圾回收器回收这些资源。例如：

```javascript
function addEvent(element) {
  var largeData = new Array(1000000).join('*');

  var handler = function() {
    console.log('Element clicked, largeData length: ' + largeData.length);
  };

  element.onclick = function() {
    handler();
    largeData = null; // 解除对 largeData 的引用
  };
}
```



3. **避免在事件处理函数中使用闭包**：在上面的例子中，我们可以将闭包在事件处理函数之外执行，将处理结果传递给事件处理函数。这样可以避免在事件处理函数中形成闭包，从而减少内存泄漏的风险。

```javascript
function createLargeData() {
  var largeData = new Array(1000000).join('*');
  return function() {
    console.log('Element clicked, largeData length: ' + largeData.length);
  };
}

var handler = createLargeData();

function addEvent(element) {
  element.onclick = handler;
}

// 当不再需要事件处理函数时，解除引用
handler = null;
```